% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

% This is a simple template for a LaTeX document using the "article" class.
% See "book", "report", "letter" for other types of document.

\documentclass[11pt,abstracton]{scrreprt} % use larger type; default would be 10pt

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)
\usepackage{german}
%%% Examples of Article customizations
% These packages are optional, depending whether you want the features they provide.
% See the LaTeX Companion or other references for full information.

%%% PAGE DIMENSIONS
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or....
% \geometry{margins=2in} % for example, change the margins to 2 inches all round
% \geometry{landscape} % set up the page for landscape
%   read geometry.pdf for detailed page layout information

\usepackage{graphicx} % support the \includegraphics command and options

% \usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

%%% PACKAGES
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
\usepackage{german}
\usepackage{url}
\usepackage[colorlinks=true]{hyperref}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{listings}
\usepackage{tikz}
\usepackage{pgfplots}
\usetikzlibrary{arrows,%
                petri,%
                topaths}%
\usepackage{tkz-berge}
\usepackage{algorithm}% http://ctan.org/pkg/algorithms
\usepackage{algpseudocode}% http://ctan.org/pkg/algorithmicx
% These packages are all incorporated in the memoir class to one degree or another...

\usepackage{listings}
\usepackage{color}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   language=JavaScript,
   backgroundcolor=\color{lightgray},
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   %numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b
}

%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
% (This matches ConTeXt defaults)

%%% ToC (table of contents) APPEARANCE
\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!

%%% END Article customizations

%%% The "real" document content comes below...

\theoremstyle{definition}
\newtheorem*{beisp}{Beispiel}
\newtheorem{definition}{Definition}
\newtheorem*{bemerkung}{Bemerkung}

\title{Graph Coloring als Online-Problem mit bipartiten Graphen und Advice Complexity}
\subtitle{Semesterarbeit}
\author{Florian Lüthi\footnote{\url{luethifl@students.zhaw.ch}}}
\date{ZHAW, 22. November 2013} % Activate to display a given date or no date (if empty),
         % otherwise the current date is printed 

\begin{document}
\maketitle

\begin{abstract}
Dies ist die Zusammenfassung.
\end{abstract}

\tableofcontents

\chapter{Einleitung}


\chapter{Advice Complexity}

\section{Online- vs. Offline-Probleme}

Optimierungsprobleme lassen sich (unter vielerlei anderen Klassifikationsmöglichkeiten) in Online-Probleme und Offline-Probleme mit dazugehörigen Online- bzw. Offline-Algo\-rithmen unterteilen. Der wesentliche Unterschied zwischen diesen beiden Klassen besteht darin, dass ein Offline-Algorithmus seine gesamte Eingabe zur Laufzeit kennt, während ein Online-Algorithmus dies nicht tut. Er bekommt einen Teil der Eingabe und berechnet daraus sofort einen Teil des Resultats. Ein solches Teilresultat kann im Nachhinein nicht mehr geändert werden.

Es liegt nun auf der Hand, dass ein Online-Algorithmus dazu tendiert, während der Berechnung eines Teilresultats Entscheidungen zu treffen, welche sich nach Berechnungen weiterer Teilresultate als suboptimal herausstellen -- dies insbesondere darum, weil die während der Berechnung des Teilresultats $i$ zur Verfügung stehenden Informationen über das gesamte Problem nur aus den Teileingaben der Berechnungen $1$ bis $i$ stammen können \cite{BKK}.

\bigskip
Eine weitere Folge des obengenannten Unterschieds manifestiert sich darin, dass ein Online-Algorithmus im Allgemeinen offensichtlich keine optimale Lösung findet. Auf der anderen Seite funktioniert ein qualitativer Vergleich zweier Algorithmen dadurch, dass deren asymptotische Laufzeitkomplexität verglichen wird. Da sich die Qualität der von einem Online-Algorithmus und dessen Offline-Pendant produzierten Lösungen grundlegend unterscheidet (während letzterer eine optimale Lösung anstrebt, ist ersterem diese konzeptbedingt verwehrt), muss eine andere Möglichkeit gefunden werden, diese beiden Algorithmen (und deren Lösungen) vergleichen zu können.

\section{Competitive Ratio}

Eine gängige Möglichkeit, dieses Problem zu lösen, ist die von Sleator und Tarjan eingeführte {\it Competitive Ratio} \cite{Sleator, BKK}, welche im Grunde genommen das Verhältnis zwischen den Kosten der optimalen Lösung und derer des zu untersuchenden Online-Algorithmus ausdrückt \cite{BKK}. Da die Qualität der Lösung eines Online-Algorithmus wesentlich von der Beschaffenheit der Eingabe abhängt, wird dabei vom jeweils schlechtestmöglichen Fall ausgegangen \cite{Trevisan}.

\bigskip
Formal kann die Competitive Ratio folgendermassen definiert werden: Sei $\operatorname{opt}(I)$ die optimale Lösung eines konkreten Online-Problems für eine Sequenz aus Teileingaben $I$. $\mathcal{I}$ sei die Menge aller möglicher solcher Sequenzen. Seien ferner $\mathcal{S}$ alle möglichen Lösungen (mit $\operatorname{opt}(I) \in \mathcal{S}$), $A(I) \in \mathcal{S}$ diejenige Lösung, welche der Online-Algorithmus zu diesem Problem liefern kann, und $C : \mathcal{S} \rightarrow \mathbb{R}$ die Kosten für die jeweilige Lösung.

\bigskip
Ein Online-Algorithmus wird nun als {\it $c$-kompetitiv} bezeichnet, wenn es Konstanten $c \ge 0$ und $\alpha$ gibt, sodass für sämtliche mögliche Eingaben $I$
\[
C(A(I)) \le c\cdot C(\operatorname{opt}(I)) + \alpha
\]
gilt \cite{BKK}, und die Competitive Ratio wäre ergo
\[
c = \max_{I \in \mathcal{I}} \left\{ \frac {C(A(I))}{C(\operatorname{opt}(I))} \right\}.
\]

\section{Das {\sc SkiRental}-Problem}

Die Competitive Ratio lässt sich durch das wohlbekannte {\sc SkiRental}-Problem illustrieren: Nehmen wir an, wir wollen zum ersten Mal ein Wochenende lang Skifahren gehen. Wir besitzen aber keine Skis. Es stellt sich nun die Frage, ob wir Skis mieten oder kaufen wollen -- wobei erschwerend hinzukommt, dass wir momentan noch keine Ahnung haben, wieviele Wochenenden wir danach noch skifahrend verbringen möchten.

Angenommen, der Kauf eines Paars Ski kostet CHF 500, die Miete äquivalenter Skis für ein Wochenende hingegen CHF 50.\footnote{In der Realität wesentliche Aspekte wie Preisveränderungen über die Zeit, veränderte Qualitätsansprüche und Abnützung der Skis sollen bei dieser Betrachtung vernachlässigt werden.} Es ist nun einfach auszurechnen, dass sich der Kauf der Skis vor dem ersten Wochenende nur lohnen würde, wenn wir an mindestens 10 Wochenenden Skifahren gehen würden.

\bigskip
Da wir das aber nicht wissen, sind wir quasi der Online-Algorithmus, der für jede Teileingabe (sprich für jedes geplante Skiwochenende) sofort die Frage nach Kauf oder Miete beantworten muss. Die Teileingabe für den Algorithmus ist jeweils die Anzahl an vergangenen Skiwochenenden.

Die oben besprochene Eigenschaft der potenziellen Suboptimalität der Entscheidungen wird beim zehnten solchen Wochenende augenscheinlich, wenn bei den vorangegangen Wochenenden die Entscheidung jeweils auf Mieten gefallen sein sollte.

\bigskip
Bezeichne $t$ nun dasjenige Wochenende, an welchem wir uns dafür entscheiden, die Skis zu kaufen. Wir schauen uns die folgenden Fälle an:

\begin{itemize}
\item Für $t = 1$ gilt, dass $A(I) = 500$, denn wir kaufen ja gleich beim ersten Mal. Die Competitive Ratio $c$ hingegen liegt bei $10$, da wir im schlechtesten Fall nur dieses eine Mal Skifahren gehen -- es gälte also $\operatorname{opt}(I) = 50$.

\item Für $t = 2$ gilt, dass $A(I) = 550$, denn wir mieten beim ersten (CHF 50) und kaufen beim zweiten Mal (CHF 500). Die Competitive Ratio $c$ liegt bei $5.5$, da wir im schlechtesten Fall nur diese zwei Male Skifahren gehen -- optimal wäre zwei Mal mieten, also  $\operatorname{opt}(I) = 50$.

\item Für $t = 10$ gilt, dass $A(I) = 950$, denn wir mieten die ersten neun Male (CHF 450) und kaufen beim zehnten Mal (CHF 500). Für die optimale Lösung spielt es keine Rolle, ob gemietet oder gekauft wird, also ist $\operatorname{opt}(I) = 500$. Dies ergibt eine Competitive Ratio von $c = 1.9$.

\item Für $t = 11$ gilt, dass $A(I) = 1000$, denn wir mieten die ersten zehn Male (CHF 500) und kaufen beim elften Mal (CHF 500). Die Competitive Ratio $c$ liegt bei $c = 2$, da es optimal wäre, gleich beim ersten Mal die Skis zu kaufen (CHF 500).
\end{itemize}

Der Verlauf von $\operatorname{opt}(I)$ und $A(I)$ ist in Abbildung \ref{fig.skirental} skizziert, Abbildung \ref{fig.skirental.c} zeigt $c$ in Abhängigkeit von $t$.

\begin{figure}
\caption{Verlauf von Lösung und Optimum für SkiRental}
\label{fig.skirental}
\begin{center}
\begin{tikzpicture}
  \begin{axis}[ 
    xlabel=$t$,
    ylabel={Kosten},
	legend pos=north west
  ] 
    \addplot coordinates {
		(1,50)
		(2,100)
		(3,150)
		(4,200)
		(5,250)
		(6,300)
		(7,350)
		(8,400)
		(9,450)
		(10,500)
		(11,500)
		(12,500)
		(13,500)
		(14,500)
		(15,500)
		(16,500)
		(17,500)
	};
	\addlegendentry{$\operatorname{opt}(I)$}
    \addplot coordinates {
		(1,500)
		(2,550)
		(3,600)
		(4,650)
		(5,700)
		(6,750)
		(7,800)
		(8,850)
		(9,900)
		(10,950)
		(11,1000)
		(12,1050)
		(13,1100)
		(14,1150)
		(15,1200)
		(16,1250)
		(17,1300)
	};
	\addlegendentry{$A(I)$}
  \end{axis}
\end{tikzpicture}
\end{center}
\end{figure}

\begin{figure}
\caption{Verlauf der Competitive Ratio für SkiRental}
\label{fig.skirental.c}
\begin{center}
\begin{tikzpicture}
  \begin{axis}[ 
    xlabel=$t$,
    ylabel={$c(t)$},
	legend pos=north west
  ] 
    \addplot coordinates {
		(1,10)
		(2,5.5)
		(3,4)
		(4,3.25)
		(5,2.8)
		(6,2.5)
		(7,2.2857142857)
		(8,2.125)
		(9,2)
		(10,1.9)
		(11,2)
		(12,2.1)
		(13,2.2)
		(14,2.3)
		(15,2.4)
		(16,2.5)
		(17,2.6)
	};
  \end{axis}
\end{tikzpicture}
\end{center}
\end{figure}

\bigskip
Allgemein kann die Competitive Ratio für dieses Problem (mit allgemeinen Kosten $b$ für den Kauf bzw. $r$ für die Miete) beschrieben werden als
\[
	c(t) = \begin{cases}
		\frac{b+(t-1)\cdot r}{t\cdot r}, & \text{wenn } r\cdot t \le b \\
		\frac{b+(t-1)\cdot r}{b}, & \text{sonst}.
	\end{cases}
\]

Unsere Instanz des {\sc SkiRental}-Problems ist also $1.9$-kompetitiv; im Allgemeinen ist {\sc SkiRental} $(2-\frac r b)$-kompetitiv \cite{Dobrev}.

\bigskip
Zurück auf die Realität bezogen, scheint es eine sinnvolle Strategie bei {\sl Kaufen oder Mieten}-Problemen zu sein, das Objekt zu dem Zeitpunkt zu kaufen, an dem die kumulierten Mietkosten die Kaufkosten aufwiegen oder überschreiten -- die Competitive Ratio ist zu diesem Zeitpunkt die beste. Ausserdem kann die Annahme getroffen werden, dass die Wahrscheinlichkeit für eine weitere Benutzung des entsprechenden Objekts um einen mindestens gleich langen Zeitraum wie während der Mietphase (während welcher sich die Kaufkosten amortisieren) relevant ist \cite{Trevisan}.


\section{Das Orakel}

Es ist augenscheinlich, dass die Lösung $t = 10$ für unsere Instanz des {\sc SkiRental}-Problems die beste Approximation ist, welche wir erreichen können, solange wir nicht in die Zukunft schauen können. Nichtsdestotrotz ist diese Lösung offensichtlich weit entfernt davon, optimal zu sein -- im schlechtesten Fall würden wir $1.9$ mal so viel für unsere Skis bezahlen wie eigentlich nötig.

\bigskip
Entsprechend interessant wäre es, eine Aussage darüber machen zu können, wieviel zusätzliche Information der Online-Algorithmus zur Verfügung haben müsste, um das Problem optimal (oder mit einer festgelegten Competitive Ratio \cite{BKK}) lösen zu können. Während die Competitive Ratio die Kosten darstellt, welche durch die gefundene Lösung zusätzlich zur optimalen Lösung zu gewärtigen wären, würde diese Aussage den Zusatznutzen beschreiben, welcher sich durch den Preis dieser zusätzlichen Kosten erkaufen liesse \cite{Dobrev}.

\bigskip
Für unser {\sc SkiRental}-Problem ist die Antwort denkbar trivial: Es ist vollkommen ausreichend, bei der ersten Entscheidung (sprich bei der Berechnung des ersten Teilresultats) zu wissen, ob die Skis gekauft werden  oder ob sie für dieses und alle weiteren Wochenenden gemietet werden sollen -- mit einem einzigen Bit zusätzlicher Information könnte das Problem also optimal gelöst werden.

\bigskip
{\sc SkiRental} ist insofern speziell, als dass dem ganzen Leben (und damit auch der Freizeitplanung) nichtdeterministische Aspekte innewohnen; aus diesem Grunde wird die benötigte Information von keiner Instanz geliefert werden können. Auf der anderen Seite sind aber durchaus Probleme denkbar, welche eigentlich Online-Probleme sind (oder aus praktischen Gründen von Online-Algorithmen gelöst werden), die Qualität der Resultat aber nachhaltig verbessert werden könnte, wenn zusätzliche Offline-Informationen aus der gesamten Eingabe herangezogen werden könnten. Deren Beschaffung könnte mit derart hohen Kosten verbunden sein, dass die Bestrebung wäre, einen möglichst guten Kompromiss zwischen diesen Kosten und der verbesserten Competitive Ratio zu erreichen \cite{Dobrev}.

\bigskip
Interesssant wäre es darum, ein Modell zur Verfügung zu haben, mit welchem sich Probleme nach Anzahl und Art der zusätzlich benötigten Informationen klassifizieren liessen. \cite{Dobrev} schlägt ein solches Modell vor \cite{BKK} -- die sogenannte {\sl Advice Complexity}. Das Modell nimmt die Existenz eines {\sl Orakels} $\mathcal{O}$ an, welchem das Problem in seiner Gesamtheit bekannt ist und welches über unlimitierte Rechenleistung verfügt \cite{Dobrev, BKK}. Das Orakel stellt dem Algorithmus $\mathcal{A}$ bitweise Informationen zur Verfügung \cite{Dobrev}. Das Mass der {\sl Advice Complexity} bezeichnet demzufolge die Menge der zwischen dem Algorithmus und dem Orakel ausgetauschten Informationen. Da diese Menge an Informationen generell von der Länge der Eingabe abhängt, bezeichnet die Advice Complexity von $\mathcal{A}$ für Eingaben der Länge $n$ das Maximum an Advice Complexitiy für alle Abfragen für Totaleingaben mit maximaler Länge von $n$, normalisiert auf $n$ \cite{BKK}:

\[
	B_{(\mathcal{A}, \mathcal{O})} = \max_{I \in \mathcal{I}^n} \frac { B_{(\mathcal{A}, \mathcal{O})}(I) }{n},
\]

während die Advice Complexity des Problems $\mathcal{P}$ definiert ist als diejenige Advice Complexity des besten Algorithmus \cite{bipartite}.

\bigskip

\cite{Dobrev} schlägt vor, die Kommunikation zwischen dem Orakel und dem Algorithmus in wahlweise zwei verschiedenen Modi ablaufen zu lassen:

\begin{itemize}
\item Im {\sl Answerer}-Modus entscheidet der Algorithmus selbständig, ob und für welche Eingaben er das Orakel um Rat fragen muss. Für jede Anfrage schickt das Orakel einen Advice-String zurück, welcher aber nicht leer sein kann \cite{Dobrev} (denn dies wäre ja kein sinnvoller Rat).

Bezogen auf {\sc SkiRental} würde der Algorithmus das Orakel vor dem ersten Wochenende fragen, ob er die Skis kaufen oder mieten soll, und das Orakel würde diese Frage mit {\sl Kaufen} oder {\sl Mieten} beantworten. Danach wäre keine weitere Kommunikation zwischen Orakel und Algorithmus notwendig.

\item Im {\sl Helper}-Modus schickt das Orakel dem Algorithmus sporadisch und spontan Advices. Wir können uns das so vorstellen, dass der Algorithmus mehrere voneinander unabhängige Verhaltensmuster für die Berechnung der Teilausgabe aufweist, welche vom Orakel entsprechend aufgerufen werden können. Bei jedem notwendigen Wechsel des Verhaltensmusters würde das Orakel erneut einen Advice senden.

Bezogen auf {\sc SkiRental} würde das Orakel den Algorithmus vor dem ersten Wochenende entweder in den {\sl Kaufen}- oder {\sl Mieten}-Modus versetzen. Der {\sl Kaufen}-Modus kauft die Skis für die erste Teileingabe und tut nichts mehr für alle folgenden Teileingaben, während der {\sl Mieten}-Modus für jede Teileingabe die Skis mietet.
\end{itemize}

\bigskip

Wir beobachten, dass die Länge der vom Orakel gegebenen Advice-Strings ebenfalls Informationen beinhalten (beispielsweise zeigt ein leerer String im {\sl Helper}-Modus dem Algorithmus an, das momentane Verhaltensmuster beizubehalten). Dies ist insofern ein Problem, als dass es das Modell einerseits komplexer als notwendig macht. Andererseits wird der Vergleich von Advice Complexity mit anderen Komplexitätsmassen dadurch erschwert \cite{BKK}.

\cite{BKKR} entwickelt dieses Modell der Advice Complexity dahingehend weiter, als dass die Existenz eines {\sl Advice Tapes} angenommen wird, wohin das Orakel alle Advices sequentiell schreibt, und zwar vor der Berechnung der ersten Teileingabe durch den Algorithmus. Dadurch wird das Modell direkt vergleichbar mit demjenigen von randomisierten Online-Algorithmen \cite{BKK}; es kann konstatiert werden, dass für jeden randomisierten Online-Algorithmus $\mathcal{R}$, welcher $b$ Bits von seinem Random-Tape liest und eine Competitive Ratio von $r$ erreicht, ein Algorithmus mit Advice $\mathcal{A}$ und Orakel $\mathcal{O}$ existiert, welcher $b$ Advice-Bits benötigt und dessen Competitive Ratio ebenfalls $r$ ist \cite{BKKR}. Dies ist einfach durch die Konstruktion von $\mathcal{O}$ dahingehend zu erreichen, dass $\mathcal{O}$ dieselben Bits auf das Advice Tape schreibt, wie auf dem Random Tape für den randomisierten Algorithmus stehen würden.

\section{Online {\sc SimpleKnapsack} mit Advice}

Um die teilweise überraschenden Fähigkeiten von Algorithmen mit Advice zu demonstrieren, wollen wir uns das {\sc SimpleKnapsack}-Problem anschauen: Wir nehmen die Existenz eines Rucksacks an. Dieser Rucksack hat eine maximale Kapazität von $1$. Des weiteren nehmen wir eine Menge von Gegenständen $S = \{ w_1, \dots, w_n \}$ (deren $w_i$ die entsprechenden Grössen ausdrücken, mit $0 < w_i \le 1$) an. Das Ziel ist, den Rucksack möglichst gut (aber nur bis zur Kapazitätsgrenze) zu füllen.

Erschwerend kommt noch hinzu, dass dieses Problem als Online-Problem formuliert wird -- der Algorithmus bekommt also einen Gegenstand präsentiert und muss sofort entscheiden, ob er diesen im Rucksack verstauen will oder nicht. Das nachträgliche Entfernen von bereits verstauten Gegenständen ist nicht erlaubt \cite{knapsack}.

\bigskip
Allgemein existiert kein kompetitiver deterministischer Online-Algorithmus \cite{spaccamela}; die einzige Möglichkeit besteht im Grunde genommen darin, sämtliche präsentierten Gegenstände der Reihe nach einzupacken, solange sie noch in den Rucksack passen. Ein möglicher Adversary wäre nun die Sequenz $\langle \varepsilon, 1 \rangle$, wobei $\varepsilon$ beliebig nahe an $0$ gewählt werden könnte; dies führt dazu, dass der Algorithmus $\varepsilon$ in den Rucksack packt und dann aufhören muss, weil $\varepsilon + 1$ die Kapazitätsgrenze überschreiten würde.

Die Competitive Ratio dieses Algorithmus wäre entsprechend
\[
	r = \lim_{\varepsilon \rightarrow 0} \frac {1} { \varepsilon} = \infty.
\]

Wenn wir nun ein Orakel dazudenken, welches dem Algorithmus bei der ersten Entscheidung mitteilt, ob in der Sequenz ein Gegenstand $w_i$ vorkommt, für welchen $w_i \ge 0.5$ gilt, könnte der Algorithmus folgende Fallunterscheidung machen:

\begin{enumerate}[a)]
\item Falls ein solcher Gegenstand vorkommt, würde der Algorithmus solange alle Gegenstände verwerfen, bis ein Gegenstand mit $w_i \ge 0.5$ zur Debatte steht. Diesen würde er wie auch alle nachfolgenden in den Rucksack packen. Da er zumindest ersteren gepackt hat, hätte der Rucksack mindestens eine Gesamtfüllung von $0.5$.
\item Falls hingegen kein solcher Gegenstand vorkommt, würde der Algorithmus von Anfang an alle Gegenstände in den Rucksack packen. Der Rucksack wäre damit ebenfalls zu mindestens zur Hälfte gefüllt, da es keinen Gegenstand $\ge 0.5$ geben kann, der nicht in den Rucksack passen würde (ansonsten Fall a) zur Anwendung gelangt wäre).
\end{enumerate}

Daraus folgt, dass die Competitive Ratio des Algorithmus mit einem einzigen Advice Bit
\[
	r = \frac 1 {0.5} = 2
\]
ist \cite{knapsack}.

\bigskip
Spannenderweise wird die Competitive Ratio für $b \in \mathcal{O}(1)$ nicht wesentlich verbessert. Der Grund dafür ist im Prinzip, dass eine konstante Anzahl an Advice Bits nicht ausreichen kann, um genügend Informationen darüber transportieren zu können, welche Gegenstände ausgewählt werden sollen. Für $b \in \mathcal{O}(\log(n))$ gilt dies hingegen -- die Competitive Ratio reduziert sich dann auf $r = 1 + \varepsilon$ \cite{knapsack}.









\chapter{Online Coloring von bipartiten Graphen}

\section{Modelle von (bipartiten) Graphen}

Im weiteren Verlauf dieser Arbeit wollen wir uns mit einer speziellen Variante des Graphenfärbeproblems beschäftigen. Damit wir dies tun können, wollen wir einige Begriffe definieren:

\begin{definition}[Graph]

Ein (ungerichteter, ungewichteter) Graph ist ein Tupel
\[
	G = (V, E),
\]
wobei $V = \{v_1, v_2, \dots \}$ dessen Knoten {\sl (vertices)} bezeichnet und $E = \{ e_1, e_2 \}$ dessen Kanten {\sl (edges)}. Jedes $e$ ist eine 2-elementige Teilmenge von $V$. \cite{biggs}

\end{definition}

Abbildung \ref{graph} illustriert einen Graphen mit
\[
	V = \{v_1,v_2,v_3,v_4,v_5,v_6\}
\]
und
\[
	E = \left\{  \{v_1,v_2\}, \{v_3,v_6\}, \{v_2,v_5\}, \{v_3,v_4\}  \right\}.
\]

\bigskip
Um einen gerichteten Graphen zu erhalten, würden wir die Definition von $E$ so abändern, dass $E$ nicht eine Menge von Teilmengen von $V$ wäre, sondern eine Menge von Tupeln, so dass
\[
E \subset V \times V;
\]
gerichtete Graphen sind für diese Arbeit aber nicht weiter interessant. Dasselbe gilt für gewichtete Graphen; bei diesen wären entweder die Knoten gewichtet (das heisst, wir bräuchten eine zusätzliche Abbildung $w_v : V \rightarrow \mathbb{R}$) oder die Kanten gewichtet (durch eine entsprechende Abbildung $w_e : E \rightarrow \mathbb{R}$).

\begin{figure}
\caption{Ein Graph}
\label{graph}
\begin{center}

\begin{tikzpicture}[scale=0.75,transform shape]
\Vertex[x=0,y=0,L=$v_1$]{A}
\Vertex[x=2,y=5,L=$v_2$]{B}
\Vertex[x=0,y=2,L=$v_3$]{C}
\Vertex[x=0,y=3,L=$v_4$]{D}
\Vertex[x=5,y=4,L=$v_5$]{E}
\Vertex[x=3,y=0,L=$v_6$]{F}

\Edge(A)(B)
\Edge(C)(F)
\Edge(B)(E)
\Edge(C)(D)
\end{tikzpicture}

\end{center}
\end{figure}

\begin{definition}[Bipartiter Graph]
Wenn alle Knoten eines Graphen $G$ so in zwei disjunkte Mengen $S_1$ und $S_2$ (Partitionsklassen oder {\sl shores}) aufgeteilt werden können, dass keine Kanten von $G$ zwischen Knoten aus $S_1$ und solchen aus $S_2$ existieren, sprechen wir von einem bipartiten Graphen.
\end{definition}

Abbildung \ref{bipartGraph} illustriert einen bipartiten Graphen mit
\[
	V = S_1 \cup S_2 = \{v_1,v_2,v_5,v_7,v_8\} \cup \{ v_3,v_4,v_6,v_9 \}
\]
und
\[
	E = \left\{  \{v_1,v_3\}, \{v_2,v_3\}, \{v_2,v_9\}, \{v_4,v_8\}, \{v_5,v_6\}, \{ v_6,v_8 \}, \{ v_7,v_9 \}  \right\}.
\]

\begin{figure}
\caption{Ein bipartiter Graph}
\label{bipartGraph}
\begin{center}

\begin{tikzpicture}[scale=0.75,transform shape]

\Vertex[x=0,y=0,L=$v_1$]{A1}
\Vertex[x=1,y=0,L=$v_2$]{A2}
\Vertex[x=2,y=4,L=$v_3$]{A3}
\Vertex[x=3,y=4,L=$v_4$]{A4}
\Vertex[x=4,y=0,L=$v_5$]{A5}
\Vertex[x=5,y=4,L=$v_6$]{A6}
\Vertex[x=6,y=0,L=$v_7$]{A7}
\Vertex[x=7,y=0,L=$v_8$]{A8}
\Vertex[x=8,y=4,L=$v_9$]{A9}

\Edge(A1)(A3)
\Edge(A2)(A3)
\Edge(A2)(A9)
\Edge(A7)(A9)
\Edge(A5)(A6)
\Edge(A6)(A8)
\Edge(A4)(A8)
\end{tikzpicture}

\end{center}
\end{figure}

\section{Zufallsgraphen}

Wenn wir Eigenschaften von vielen Graphen betrachten wollen, sind Zufallsgraphen ein hilfreicher Denkansatz. Das grundlegende Prinzip ist, eine feste Menge von Knoten $V$ anzunehmen und dann aus allen möglichen Kombinationen von Kanten (sprich aus der Potenzmenge $\mathcal{P}(E)$) mit einer definierten Wahrscheinlichkeit auszuwählen.

\bigskip
Das verbreitete Modell der Erdös-Renyi-Graphen definiert eine Klasse von Graphen $G(n, p)$ mit einer Anzahl Knoten $n$ und einer gleichverteilten Wahrscheinlichkeit $p$, dass eine Kante zwischen zwei Knoten besteht \cite{erdos}.

Da ein solcher Graph maximal $|\mathcal{P}(E)| = \binom{n}{2}$ Kanten haben kann, beträgt die Wahrscheinlichkeit, dass darin ein Graph mit genau $k$ Kanten auftritt, gegeben als
\[
\mathbb{P}(G) = p^k(1-p)^{\binom{n}{2}- k}.
\]

Es ist natürlich möglich, dass einzelne Knoten eines solchen Graphen gar keine Kanten haben, sprich das zusammenhängende Graph-Gebilde nicht alle $n$ Knoten beinhaltet. Diese Knoten werden aber trotzdem zum Graphen dazugezählt. \cite{erdos}

Abbildung \ref{pdistribution} zeigt die Auftretenswahrscheinlichkeit eines Graphen in $G(10, p)$ abhängig von der Anzahl Kanten für $p = 0.2, 0.5, 0.8.$

\begin{figure}
\caption{Verteilung der Auftretenswahrscheinlichkeit eines Zufallsgraphen}
\label{pdistribution}
\begin{center}
\begin{tikzpicture}
  \begin{semilogyaxis}[ 
    xlabel=$k$,
    ylabel={$\mathbb{P}(G(10, p))$},
	legend pos=north west
  ] 
    \addplot[mark=none,color=blue] coordinates {
(0,4.35561429658803E-05)
(1,1.08890357414701E-05)
(2,2.72225893536752E-06)
(3,6.8056473384188E-07)
(4,1.7014118346047E-07)
(5,4.25352958651175E-08)
(6,1.06338239662794E-08)
(7,2.65845599156984E-09)
(8,6.64613997892461E-10)
(9,1.66153499473115E-10)
(10,4.15383748682788E-11)
(11,1.03845937170697E-11)
(12,2.59614842926743E-12)
(13,6.49037107316857E-13)
(14,1.62259276829214E-13)
(15,4.05648192073035E-14)
(16,1.01412048018259E-14)
(17,2.53530120045647E-15)
(18,6.33825300114118E-16)
(19,1.58456325028529E-16)
(20,3.96140812571324E-17)
(21,9.90352031428309E-18)
(22,2.47588007857077E-18)
(23,6.18970019642693E-19)
(24,1.54742504910673E-19)
(25,3.86856262276683E-20)
(26,9.67140655691708E-21)
(27,2.41785163922927E-21)
(28,6.04462909807317E-22)
(29,1.51115727451829E-22)
(30,3.77789318629573E-23)
(31,9.44473296573934E-24)
(32,2.36118324143483E-24)
(33,5.90295810358708E-25)
(34,1.47573952589677E-25)
(35,3.68934881474193E-26)
(36,9.22337203685482E-27)
(37,2.30584300921371E-27)
(38,5.76460752303426E-28)
(39,1.44115188075857E-28)
(40,3.60287970189641E-29)
(41,9.00719925474104E-30)
(42,2.25179981368526E-30)
(43,5.62949953421315E-31)
(44,1.40737488355329E-31)
(45,3.51843720888322E-32)
	};
	\addlegendentry{$p = 0.2$}
    \addplot[mark=none,color=green] coordinates {
(0,2.8421709430404E-14)
(1,2.8421709430404E-14)
(2,2.8421709430404E-14)
(3,2.8421709430404E-14)
(4,2.8421709430404E-14)
(5,2.8421709430404E-14)
(6,2.8421709430404E-14)
(7,2.8421709430404E-14)
(8,2.8421709430404E-14)
(9,2.8421709430404E-14)
(10,2.8421709430404E-14)
(11,2.8421709430404E-14)
(12,2.8421709430404E-14)
(13,2.8421709430404E-14)
(14,2.8421709430404E-14)
(15,2.8421709430404E-14)
(16,2.8421709430404E-14)
(17,2.8421709430404E-14)
(18,2.8421709430404E-14)
(19,2.8421709430404E-14)
(20,2.8421709430404E-14)
(21,2.8421709430404E-14)
(22,2.8421709430404E-14)
(23,2.8421709430404E-14)
(24,2.8421709430404E-14)
(25,2.8421709430404E-14)
(26,2.8421709430404E-14)
(27,2.8421709430404E-14)
(28,2.8421709430404E-14)
(29,2.8421709430404E-14)
(30,2.8421709430404E-14)
(31,2.8421709430404E-14)
(32,2.8421709430404E-14)
(33,2.8421709430404E-14)
(34,2.8421709430404E-14)
(35,2.8421709430404E-14)
(36,2.8421709430404E-14)
(37,2.8421709430404E-14)
(38,2.8421709430404E-14)
(39,2.8421709430404E-14)
(40,2.8421709430404E-14)
(41,2.8421709430404E-14)
(42,2.8421709430404E-14)
(43,2.8421709430404E-14)
(44,2.8421709430404E-14)
(45,2.8421709430404E-14)
	};
	\addlegendentry{$p = 0.5$}
    \addplot[mark=none,color=red] coordinates {
(0,3.51843720888316E-32)
(1,1.40737488355326E-31)
(2,5.62949953421306E-31)
(3,2.25179981368522E-30)
(4,9.0071992547409E-30)
(5,3.60287970189636E-29)
(6,1.44115188075855E-28)
(7,5.76460752303418E-28)
(8,2.30584300921367E-27)
(9,9.2233720368547E-27)
(10,3.68934881474188E-26)
(11,1.47573952589675E-25)
(12,5.90295810358701E-25)
(13,2.36118324143481E-24)
(14,9.44473296573923E-24)
(15,3.77789318629569E-23)
(16,1.51115727451828E-22)
(17,6.04462909807311E-22)
(18,2.41785163922925E-21)
(19,9.67140655691699E-21)
(20,3.8685626227668E-20)
(21,1.54742504910672E-19)
(22,6.18970019642688E-19)
(23,2.47588007857075E-18)
(24,9.90352031428301E-18)
(25,3.96140812571321E-17)
(26,1.58456325028528E-16)
(27,6.33825300114113E-16)
(28,2.53530120045646E-15)
(29,1.01412048018258E-14)
(30,4.05648192073033E-14)
(31,1.62259276829213E-13)
(32,6.49037107316854E-13)
(33,2.59614842926741E-12)
(34,1.03845937170697E-11)
(35,4.15383748682787E-11)
(36,1.66153499473115E-10)
(37,6.64613997892459E-10)
(38,2.65845599156984E-09)
(39,1.06338239662794E-08)
(40,4.25352958651174E-08)
(41,1.7014118346047E-07)
(42,6.8056473384188E-07)
(43,2.72225893536752E-06)
(44,1.08890357414701E-05)
(45,4.35561429658803E-05)
	};
	\addlegendentry{$p = 0.8$}
  \end{semilogyaxis}
\end{tikzpicture}
\end{center}
\end{figure}

\floatname{algorithm}{Algorithmus}
\renewcommand{\algorithmicrequire}{\textbf{Eingabe:}}
\renewcommand{\algorithmicensure}{\textbf{Ausgabe:}}


\section{Generierung von Zufallsgraphen}

Zufallsgraphen zu generieren ist im Grunde genommen ziemlich einfach, wie Algorithmus~\ref{gen.naive} zeigt \cite{fastalgo}. Das Problem ist allerdings ebenfalls offensichtlich: Die Komplexitätsklasse dieses Algorithmus ist $\mathcal{O}(n^2)$.

\begin{algorithm}
\caption{Ein naiver Zufallsgraphen-Generator}
\label{gen.naive}
\begin{algorithmic}
\Require
	\Statex Anzahl Knoten $n$,
	\Statex Kantenwahrscheinlichkeit $p$.
\Ensure
	\Statex Zufallsgraph $G = (V, E)$.
\Statex
\For{$i \gets 1, n$}
\For{$j \gets i+1, n$}
\State $\theta\gets$ gleichverteilte Zufallszahl
\If{$\theta < p$}
\State $E \gets E \cup \{(v_i,v_j)\}$
\EndIf
\EndFor
\EndFor
\end{algorithmic}
\end{algorithm}


Um diese technische Suboptimalität zu lösen, verfolgen Nobari, Lu, Karras und Bressan in \cite{fastalgo} folgende Idee:

\begin{enumerate}
\item Jede Kante $(v_i, v_j)$ (und darum auch $\{v_i, v_j\}$) kann als $e_k$ ausgedrückt werden durch die Beziehungen
\[
i = \left\lfloor\frac k v \right\rfloor
\]
und
\[
j = k \mod v.
\]

\item Damit kann Algorithmus~\ref{gen.naive} $\in \mathcal{O}(n^2)$ zu einem Algorithmus mit linearer Laufzeitkomplexität $\mathcal{O}(|E|)$ umgeschrieben werden (siehe Algorithmus~\ref{gen.linear}). Da aber $|E| = \binom{n}{2}$ gilt, nützt uns das momentan noch nicht viel.

\begin{algorithm}
\caption{Ein umgeformter naiver Zufallsgraphen-Generator}
\label{gen.linear}
\begin{algorithmic}
\Require
	\Statex Kantenwahrscheinlichkeit $p$.
\Ensure
	\Statex Zufallsgraph $G = (V, E)$.
\Statex
\For{$i \gets 1, |E|$}
\State $\theta\gets$ gleichverteilte Zufallszahl
\If{$\theta < p$}
\State $E \gets E \cup \{e_i\}$
\EndIf
\EndFor
\end{algorithmic}
\end{algorithm}

\item Der eigentliche Trick folgt der Erkenntnis, dass die Wahrscheinlichkeitsverteilung einer Folge von gleichverteilten Zufallsentscheidungen, die zum selben Resultat führen, im Grunde einer geometrischen Verteilung entspricht. Dadurch können wir die Wahrscheinlichkeit, dass die nächsten $s$ Kanten des Graphen mit einer jeweiligen Wahrscheinlichkeit von $1-p$ ausgelassen werden, ausdrücken als
\[
	f(s) = p \cdot (1-p)^s,
\]
und die kumulative Verteilungsfunktion wäre (\cite{fastalgo})
\[
	F(s) = \sum\limits_{i=0}^s f(i) = 1 - (1-p)^{s+1}.
\]
Dies bedeutet, dass der Algorithmus nach jedem Setzen einer Kante eine einzige neue Zufallszahl $\alpha$ generiert, mit welcher er bestimmen kann, wieviele Kanten $s$ ausgelassen werden können (nämlich die kleinste ganze Zahl, für welche
\[
F(s) \ge \alpha
\]
gilt). Durch ein paar Takte Algebra können wir nach $s$ auflösen und bekommen eine explizite Funktion (\cite{fastalgo}):
\[
	s(\alpha) = \max(0, \left\lceil \log_{1-p}\alpha\right\rceil - 1)
\]

Damit können wir unseren Algorithmus optimieren (siehe Algorithmus~\ref{gen.opt}). Es liegt nun auf der Hand, dass dieser Algorithmus desto schneller ist, je kleiner $p$ gewählt wird. \cite{fastalgo} versucht darum, der durch die Berechnung des Logarithmus gestiegenen mathematischen Komplexität Herr zu werden, indem eine Menge an Logarithmus-Werten vorberechnet und wiederverwendet werden. Ausserdem werden noch Optimierungen vorgenommen, um den Algorithmus auf Grafik-Prozessoren laufen zu lassen. Dies ist für uns allerdings nicht weiter spannend, und darum wollen wir es bei der einfachen Optimierung wie eben gesehen belassen.

\begin{algorithm}
\caption{Ein Zufallsgraphen-Generator mit Edge Skipping}
\label{gen.opt}
\begin{algorithmic}
\Require
	\Statex Kantenwahrscheinlichkeit $p$.
\Ensure
	\Statex Zufallsgraph $G = (V, E)$.
\Statex
\Statex $i \gets -1$
\While{$i < |E|$}
\State $\alpha\gets$ gleichverteilte Zufallszahl
\State $s \gets \max(0, \left\lceil \log_{1-p}\alpha\right\rceil - 1)$
\State $i \gets i + s + 1$
\State $E \gets E \cup \{e_i\}$
\EndWhile
\State Entferne die letzte Kante
\end{algorithmic}
\end{algorithm}

\end{enumerate}

\section{Graph Coloring}

\begin{definition}[Knotenfärbung]

Für einen ungerichteten Graphen $G = (V, E)$ ist die Abbildung
\[
f : V \rightarrow C \subset \mathbb{N}
\]
eine Knotenfärbung, wenn keinen zwei Knoten, die durch eine Kante verbunden sind, dieselbe Farbe ($c \in C$) zugeordnet wird.

$G$ heisst $k$-knotenfärbbar, wenn die maximale Anzahl verwendeter Farben $k$ beträgt -- das heisst, wenn für alle $v \in V$ gilt, dass
\[
f(v) < k.
\]

Die kleinstmögliche solche Zahl $k$ wird Chromatische Zahl $\chi(G)$ geheissen.

\end{definition}

Das Auffinden einer gültigen Färbung für einen Graphen wird als Graphenfärbeproblem bezeichnet. Das dazugehörige Entscheidungsproblem, ob ein Graph $k$-färbbar ist, ist eines von Karp's 21 $\mathcal{NP}$-vollständigen Problemen \cite{hopcroft}. Praktische Anwendung finden Färbeprobleme vor allem als mathematische Formulierung von Scheduling-Problemen aller Art, beispielsweise für Stundenpläne. Ein anderes wohlstudiertes Problem ist die Frage, wie viele Farben notwendig sind, um auf einer beliebigen Landkarte jedes Land so einzufärben, dass nie zwei benachbarte Länder dieselbe Farbe haben -- mit dem lange vermuteten, aber doch überraschenden Ergebnis, dass 4 Farben ausreichend sind \cite{gonthier}.

\bigskip
Ausserdem liegt auf der Hand, dass ein bipartiter Graph stets $2$-färbbar ist.


\section{Online Graph Coloring: First Fit-Algorithmus}

Wir wollen das Graphenfärbeproblem nun als Online-Problem betrachten. Dafür stellen wir uns vor, dass der zu färbende Graph nicht komplett vorliegt, sondern jeder Knoten einzeln präsentiert wird. Jeder Knoten muss im Moment seiner Präsentation eingefärbt werden. Alle Kanten zwischen bereits aufgedeckten Knoten sind bekannt, alle anderen jedoch nicht. \cite{lovasz}

Offensichtlich kann ein solches Problem nicht per se optimal gelöst werden, da Informationen über das gesamte Problem fehlen. Abbildung~\ref{bipart.greedy} veranschaulicht den simplen First Fit-Algorithmus~\ref{algo.firstfit}, der für einen beispielhaften (aber doch unspektakulären) bipartiten Graphen folgendermassen scheitert:
\begin{enumerate}
\item Der Knoten $v_0$ wird präsentiert, und bekommt die Farbe Blau.
\item Der Knoten $v_1$ wird präsentiert, und bekommt ebenfalls die Farbe Blau, da noch keine Kante bekannt ist.
\item Der Knoten $v_2$ wird präsentiert, und mit ihm die Kante $\{v_0, v_2\}$. $v_2$ bekommt die Farbe Rot, da $v_0$ bereits die Farbe Blau bekommen hat.
\item Der Knoten $v_3$ wird präsentiert, und mit ihm die Kanten $\{v_0, v_3\}$ und $\{v_1, v_3\}$. $v_3$ bekommt die Farbe Grün, da $v_1$ bereits die Farbe Blau und $v_2$ bereits die Farbe Rot bekommen hat.
\end{enumerate}

\begin{algorithm}
\caption{First Fit-Algorithmus für Online Graph Coloring}
\label{algo.firstfit}
\begin{algorithmic}
\Require
	\State Der präsentierte Knoten $v$,
	\State Der bereits bekannte Graph $G' = (V', E')$,
	\State Die bereits bekannte Färbung $f : V' \rightarrow C$
\Ensure
	\State Die Färbung für den präsentierten Knoten $f(v) \in C$
\Statex

\State $f(v) \gets -1$
\State $c_\text{max} \gets 0 $
\ForAll{$e \in E'$}
	\State $\{w\} \gets e \cap v$
	\State $c_\text{max} \gets \max \{c_\text{max}, f(w) \}$
\EndFor

\Statex

\For{$c \gets 0, c_\text{max} - 1$}
\If {$f(v) = -1$}
\State ok $\gets$ true
\ForAll{$e \in E'$}
	\State $\{w\} \gets e \cap v$
	\State ok $\gets$ ok $\land f(w) = c$
\EndFor
\If {ok}
\State $f(v) \gets c$
\EndIf
\EndIf
\EndFor
\Statex
\If {$f(v) = -1$}
\State $f(v) \gets c_\text{max} + 1$
\EndIf

\end{algorithmic}
\end{algorithm}

Der kapitale Fehler passierte bereits beim Färben von $v_1$. Es gab anhand der bereits vorhandenen Informationen keinen Grund, nicht anzunehmen, dass $v_1$ Blau zugeordnet bekommen sollte. Wenn allerdings bekannt gewesen wäre, dass $v_1$ eine Kante zu $v_3$, dieser eine Kante zu $v_2$ und dieser wiederum eine Kante zu $v_0$ haben wird, hätte dies ausgereicht, um zu erkennen, dass $v_1$ in der gegenteiligen Shore von $v_0$ hätte platziert werden müssen, wie in Abbildung~\ref{bipart.greedy.besser} illustriert wird.

\begin{figure}
\caption{Nicht optimal färbbarer bipartiter Graph}
\label{bipart.greedy}

\begin{center}
\begin{tikzpicture}[transform shape]
\Vertex[x=0,y=0,L=$v_0$]{v0}
\Vertex[x=2,y=0,L=$v_1$]{v1}
\Vertex[x=4,y=2,L=$v_2$]{v2}
\Vertex[x=6,y=3,L=$v_3$]{v3}

\AddVertexColor{blue}{v0,v1}
\AddVertexColor{red}{v2}
\AddVertexColor{green}{v3}

\Vertex[x=0,y=-1,L=$v_0$]{A}
\Vertex[x=2,y=-1,L=$v_1$]{A}
\Vertex[x=4,y=-1,L=$v_2$]{A}
\Vertex[x=6,y=-1,L=$v_3$]{A}

\Edge(v0)(v2)
\Edge(v1)(v3)
\Edge(v2)(v3)
\end{tikzpicture}


\end{center}

\end{figure}

\begin{figure}
\caption{Optimal gefärbter bipartiter Graph}
\label{bipart.greedy.besser}

\begin{center}
\begin{tikzpicture}[transform shape]
\Vertex[x=0,y=0,L=$v_0$]{v0}
\Vertex[x=2,y=2,L=$v_1$]{v1}
\Vertex[x=4,y=2,L=$v_2$]{v2}
\Vertex[x=6,y=0,L=$v_3$]{v3}

\AddVertexColor{blue}{v0,v3}
\AddVertexColor{red}{v2,v1}

\Vertex[x=0,y=-1,L=$v_0$]{A}
\Vertex[x=2,y=-1,L=$v_1$]{A}
\Vertex[x=4,y=-1,L=$v_2$]{A}
\Vertex[x=6,y=-1,L=$v_3$]{A}

\Edge(v0)(v2)
\Edge(v1)(v3)
\Edge(v2)(v3)
\end{tikzpicture}


\end{center}

\end{figure}

\bigskip

Das Online Coloring-Problem hat keine konstante Competitive Ratio (\cite{bipartite}), wie in \cite{gyarfas} gezeigt wird. Für den Nachvollzug wollen wir uns vergegenwärtigen, dass jeder Baum ein bipartiter Graph ist, weil alle Knoten einer Ebene nur mit Knoten der jeweiligen nächsten oder vorhergehenden Ebene verknüpft sein können, wie in Abbildung~\ref{tree} skizziert.

\begin{figure}
\caption{Ein Baum}
\label{tree}
\begin{center}
\begin{tikzpicture}[scale=0.5, transform shape]
\Vertex[x=8, y=8]{A}
\Vertex[x=4, y=6]{B}
\Vertex[x=8, y=6]{C}
\Vertex[x=11, y=6]{D}
\Vertex[x=2, y=4]{E}
\Vertex[x=4, y=4]{F}
\Vertex[x=6, y=4]{G}
\Vertex[x=8, y=4]{H}
\Vertex[x=10, y=4]{I}
\Vertex[x=12, y=4]{J}

\Vertex[x=2,y=2]{l1}
\Vertex[x=4,y=2]{l2}
\Vertex[x=6,y=2]{l3}
\Vertex[x=8,y=2]{l4}
\Vertex[x=10,y=2]{l5}
\Vertex[x=12,y=2]{l6}


\Edge(A)(B)
\Edge(A)(C)
\Edge(A)(D)

\Edge(B)(E)
\Edge(B)(F)
\Edge(B)(G)

\Edge(C)(H)

\Edge(D)(I)
\Edge(D)(J)

\Edge(E)(l1)
\Edge(F)(l2)
\Edge(G)(l3)
\Edge(H)(l4)
\Edge(I)(l5)
\Edge(J)(l6)

\AddVertexColor{blue}{A,E,F,G,H,I,J}
\AddVertexColor{red}{B,C,D,l1,l2,l3,l4,l5,l6}

\end{tikzpicture}
\end{center}
\end{figure}

Wir überlegen uns nun eine rekursive Folge von Bäumen:
\begin{itemize}
\item Der Baum $T_1$ besitzt nur einen Knoten.
\item Der Baum $T_n$ besteht aus der Vereinigung von exakten Kopien aller Bäume $T_1, \dots T_{n-1}$ sowie einem zusätzlichen Knoten, der eine Kante zu den jeweiligen Wurzelknoten all dieser Bäume hat. Abbildung~\ref{tree.rec} verdeutlicht dies.
\end{itemize}

\begin{figure}
\caption{Die Folge $T_1, \dots, T_6$}
\label{tree.rec}
\begin{center}
\begin{tikzpicture}[scale=0.5, transform shape]

\Vertex[x=0, y=0,L=$$]{T1x}

\Vertex[x=2, y=2,L=$$]{T2x}
\Vertex[x=2, y=0,L=$$]{T2T1x}
\Edge(T2x)(T2T1x)

\Vertex[x=4, y=0,L=$$]{T3T1x}
\Vertex[x=6, y=2,L=$$]{T3T2x}
\Vertex[x=6, y=0,L=$$]{T3T2T1x}
\Edge(T3T2x)(T3T2T1x)
\Vertex[x=5, y=4,L=$$]{T3x}
\Edge(T3T1x)(T3x)
\Edge(T3T2x)(T3x)

\Vertex[x=8, y=0,L=$$]{T4T1x}
\Vertex[x=10, y=2,L=$$]{T4T2x}
\Vertex[x=10, y=0,L=$$]{T4T2T1x}
\Edge(T4T2x)(T4T2T1x)
\Vertex[x=12, y=0,L=$$]{T4T3T1x}
\Vertex[x=14, y=2,L=$$]{T4T3T2x}
\Vertex[x=14, y=0,L=$$]{T4T3T2T1x}
\Edge(T4T3T2x)(T4T3T2T1x)
\Vertex[x=13, y=4,L=$$]{T4T3x}
\Edge(T4T3T1x)(T4T3x)
\Edge(T4T3T2x)(T4T3x)
\Vertex[x=11,y=6,L=$x$]{T4x}
\Edge(T4x)(T4T3x)
\Edge(T4x)(T4T2x)
\Edge(T4x)(T4T1x)



\Vertex[x=16, y=0,L=$$]{T5T1x}

\Vertex[x=18, y=2,L=$$]{T5T2x}
\Vertex[x=18, y=0,L=$$]{T5T2T1x}
\Edge(T5T2x)(T5T2T1x)

\Vertex[x=20, y=0,L=$$]{T5T3T1x}
\Vertex[x=22, y=2,L=$$]{T5T3T2x}
\Vertex[x=22, y=0,L=$$]{T5T3T2T1x}
\Edge(T5T3T2x)(T5T3T2T1x)
\Vertex[x=21, y=4,L=$$]{T5T3x}
\Edge(T5T3T1x)(T5T3x)
\Edge(T5T3T2x)(T5T3x)

\Vertex[x=24, y=0,L=$$]{T5T4T1x}
\Vertex[x=26, y=2,L=$$]{T5T4T2x}
\Vertex[x=26, y=0,L=$$]{T5T4T2T1x}
\Edge(T5T4T2x)(T5T4T2T1x)
\Vertex[x=28, y=0,L=$$]{T5T4T3T1x}
\Vertex[x=30, y=2,L=$$]{T5T4T3T2x}
\Vertex[x=30, y=0,L=$$]{T5T4T3T2T1x}
\Edge(T5T4T3T2x)(T5T4T3T2T1x)
\Vertex[x=29, y=4,L=$$]{T5T4T3x}
\Edge(T5T4T3T1x)(T5T4T3x)
\Edge(T5T4T3T2x)(T5T4T3x)
\Vertex[x=27,y=6,L=$$]{T5T4x}
\Edge(T5T4x)(T5T4T3x)
\Edge(T5T4x)(T5T4T2x)
\Edge(T5T4x)(T5T4T1x)

\Vertex[x=20,y=8,L=$$]{T5x}
\Edge(T5x)(T5T4x)
\Edge(T5x)(T5T3x)
\Edge(T5x)(T5T2x)
\Edge(T5x)(T5T1x)



\Vertex[x=0, y=0-14,L=$$]{T6T1x}

\Vertex[x=2, y=2-14,L=$$]{T6T2x}
\Vertex[x=2, y=0-14,L=$$]{T6T2T1x}
\Edge(T6T2x)(T6T2T1x)

\Vertex[x=4, y=0-14,L=$$]{T6T3T1x}
\Vertex[x=6, y=2-14,L=$$]{T6T3T2x}
\Vertex[x=6, y=0-14,L=$$]{T6T3T2T1x}
\Edge(T6T3T2x)(T6T3T2T1x)
\Vertex[x=5, y=4-14,L=$$]{T6T3x}
\Edge(T6T3T1x)(T6T3x)
\Edge(T6T3T2x)(T6T3x)

\Vertex[x=8, y=0-14,L=$$]{T6T4T1x}
\Vertex[x=10, y=2-14,L=$$]{T6T4T2x}
\Vertex[x=10, y=0-14,L=$$]{T6T4T2T1x}
\Edge(T6T4T2x)(T6T4T2T1x)
\Vertex[x=12, y=0-14,L=$$]{T6T4T3T1x}
\Vertex[x=14, y=2-14,L=$$]{T6T4T3T2x}
\Vertex[x=14, y=0-14,L=$$]{T6T4T3T2T1x}
\Edge(T6T4T3T2x)(T6T4T3T2T1x)
\Vertex[x=13, y=4-14,L=$$]{T6T4T3x}
\Edge(T6T4T3T1x)(T6T4T3x)
\Edge(T6T4T3T2x)(T6T4T3x)
\Vertex[x=11,y=6-14,L=$$]{T6T4x}
\Edge(T6T4x)(T6T4T3x)
\Edge(T6T4x)(T6T4T2x)
\Edge(T6T4x)(T6T4T1x)



\Vertex[x=16, y=0-14,L=$$]{T6T5T1x}

\Vertex[x=18, y=2-14,L=$$]{T6T5T2x}
\Vertex[x=18, y=0-14,L=$$]{T6T5T2T1x}
\Edge(T6T5T2x)(T6T5T2T1x)

\Vertex[x=20, y=0-14,L=$$]{T6T5T3T1x}
\Vertex[x=22, y=2-14,L=$$]{T6T5T3T2x}
\Vertex[x=22, y=0-14,L=$$]{T6T5T3T2T1x}
\Edge(T6T5T3T2x)(T6T5T3T2T1x)
\Vertex[x=21, y=4-14,L=$$]{T6T5T3x}
\Edge(T6T5T3T1x)(T6T5T3x)
\Edge(T6T5T3T2x)(T6T5T3x)

\Vertex[x=24, y=0-14,L=$$]{T6T5T4T1x}
\Vertex[x=26, y=2-14,L=$$]{T6T5T4T2x}
\Vertex[x=26, y=0-14,L=$$]{T6T5T4T2T1x}
\Edge(T6T5T4T2x)(T6T5T4T2T1x)
\Vertex[x=28, y=0-14,L=$$]{T6T5T4T3T1x}
\Vertex[x=30, y=2-14,L=$$]{T6T5T4T3T2x}
\Vertex[x=30, y=0-14,L=$$]{T6T5T4T3T2T1x}
\Edge(T6T5T4T3T2x)(T6T5T4T3T2T1x)
\Vertex[x=29, y=4-14,L=$$]{T6T5T4T3x}
\Edge(T6T5T4T3T1x)(T6T5T4T3x)
\Edge(T6T5T4T3T2x)(T6T5T4T3x)
\Vertex[x=27,y=6-14,L=$$]{T6T5T4x}
\Edge(T6T5T4x)(T6T5T4T3x)
\Edge(T6T5T4x)(T6T5T4T2x)
\Edge(T6T5T4x)(T6T5T4T1x)

\Vertex[x=20,y=8-14,L=$$]{T6T5x}
\Edge(T6T5x)(T6T5T4x)
\Edge(T6T5x)(T6T5T3x)
\Edge(T6T5x)(T6T5T2x)
\Edge(T6T5x)(T6T5T1x)

\Vertex[x=6,y=10-14,L=$x$]{T6x}

\Edge(T6x)(T6T5x)
\Edge(T6x)(T6T4x)
\Edge(T6x)(T6T3x)
\Edge(T6x)(T6T2x)
\Edge(T6x)(T6T1x)


\AddVertexColor{black}{T1x,T2x,T3x,T4x,T5x,T6x}

\end{tikzpicture}
\end{center}
\end{figure}

Wenn wir nun die Knoten dieser Bäume in einer geeigneten Reihenfolge präsentieren, maximieren wir die Menge an verdeckter Information, welche jeden Online-Algorithmus scheitern lassen wird. Für den besprochenen First Fit-Algorithmus~\ref{algo.firstfit} gehen wir beispielsweise folgendermassen vor:
\begin{enumerate}
\item Wir präsentieren zuerst alle Knoten, welche durch rekursives Kopieren von $T_1$ entstanden sind -- diese bilden auch gleichzeitig alle Blattknoten aller Bäume. Da diese Knoten natürlich keine gemeinsamen Kanten haben, wird der Algorithmus allen dieselbe Farbe zuweisen -- beispielsweise Blau.

\item Nun präsentieren wir alle Knoten, welche durch rekursives Kopieren des für $T_2$ hinzugefügten Knotens entstanden sind. (Wenn wir uns die im vorhergehenden Schritt präsentierten Knoten aus den Bäumen wegdenken würden, würden die $T_2$-originären Knoten die neue Menge an Blattknoten bilden.) Der Algorithmus kann diese Knoten nicht blau färben, da sie alle eine Kante zu schon präsentierten Knoten haben -- ergo bekommen sie die Farbe Rot.

\item Den zweiten Schritt wiederholen wir nun für die in $T_3, T_4,\dots$ hinzugefügten und in jeden weiteren Baum kopierten Knoten. Schon bei $T_3$ stellen wir fest, dass der dazumal hinzugefügte Knoten nur eine dritte Farbe zugeordnet bekommen kann, da er Kanten zu je einem der in den beiden vorangegangenen Schritten präsentierten Knoten hat.
\end{enumerate}

Die Abbildung~\ref{tree.rec.colored} veranschaulicht das Resultat. Es ist nun offensichtlich, dass der Algorithmus für jeden Baum $T_n$ genau $n$ Farben benötigt. Da jeder dieser Bäume $2^{n-1}$ Knoten hat, und es unendlich viele solcher Bäume gibt (das Spiel lässt sich bei genügend Platz und Zeit endlos weitertreiben), konstatieren wir eine nicht-konstante Competitive Ratio von
\[
	r = \frac {\log_2 k + 1} {2}
\]
in Abhängigkeit der Anzahl Knoten $k$. Gleichzeitig ist darum $\log_2 k+1$ eine untere Schranke für die minimale Anzahl Farben von Online-Algorithmen auf bipartiten Graphen -- allerdings eine zu optimistische, denn \cite{bipartite} erhöht diese auf
\[
	1.13747 \cdot \log_2 k.
\]



\begin{figure}
\caption{First Fit auf $T_1, \dots, T_6$}
\label{tree.rec.colored}
\begin{center}
\begin{tikzpicture}[scale=0.5, transform shape]

\Vertex[x=0, y=0,L=$$]{T1x}

\Vertex[x=2, y=2,L=$$]{T2x}
\Vertex[x=2, y=0,L=$$]{T2T1x}
\Edge(T2x)(T2T1x)

\Vertex[x=4, y=0,L=$$]{T3T1x}
\Vertex[x=6, y=2,L=$$]{T3T2x}
\Vertex[x=6, y=0,L=$$]{T3T2T1x}
\Edge(T3T2x)(T3T2T1x)
\Vertex[x=5, y=4,L=$$]{T3x}
\Edge(T3T1x)(T3x)
\Edge(T3T2x)(T3x)

\Vertex[x=8, y=0,L=$$]{T4T1x}
\Vertex[x=10, y=2,L=$$]{T4T2x}
\Vertex[x=10, y=0,L=$$]{T4T2T1x}
\Edge(T4T2x)(T4T2T1x)
\Vertex[x=12, y=0,L=$$]{T4T3T1x}
\Vertex[x=14, y=2,L=$$]{T4T3T2x}
\Vertex[x=14, y=0,L=$$]{T4T3T2T1x}
\Edge(T4T3T2x)(T4T3T2T1x)
\Vertex[x=13, y=4,L=$$]{T4T3x}
\Edge(T4T3T1x)(T4T3x)
\Edge(T4T3T2x)(T4T3x)
\Vertex[x=11,y=6,L=$x$]{T4x}
\Edge(T4x)(T4T3x)
\Edge(T4x)(T4T2x)
\Edge(T4x)(T4T1x)



\Vertex[x=16, y=0,L=$$]{T5T1x}

\Vertex[x=18, y=2,L=$$]{T5T2x}
\Vertex[x=18, y=0,L=$$]{T5T2T1x}
\Edge(T5T2x)(T5T2T1x)

\Vertex[x=20, y=0,L=$$]{T5T3T1x}
\Vertex[x=22, y=2,L=$$]{T5T3T2x}
\Vertex[x=22, y=0,L=$$]{T5T3T2T1x}
\Edge(T5T3T2x)(T5T3T2T1x)
\Vertex[x=21, y=4,L=$$]{T5T3x}
\Edge(T5T3T1x)(T5T3x)
\Edge(T5T3T2x)(T5T3x)

\Vertex[x=24, y=0,L=$$]{T5T4T1x}
\Vertex[x=26, y=2,L=$$]{T5T4T2x}
\Vertex[x=26, y=0,L=$$]{T5T4T2T1x}
\Edge(T5T4T2x)(T5T4T2T1x)
\Vertex[x=28, y=0,L=$$]{T5T4T3T1x}
\Vertex[x=30, y=2,L=$$]{T5T4T3T2x}
\Vertex[x=30, y=0,L=$$]{T5T4T3T2T1x}
\Edge(T5T4T3T2x)(T5T4T3T2T1x)
\Vertex[x=29, y=4,L=$$]{T5T4T3x}
\Edge(T5T4T3T1x)(T5T4T3x)
\Edge(T5T4T3T2x)(T5T4T3x)
\Vertex[x=27,y=6,L=$$]{T5T4x}
\Edge(T5T4x)(T5T4T3x)
\Edge(T5T4x)(T5T4T2x)
\Edge(T5T4x)(T5T4T1x)

\Vertex[x=20,y=8,L=$$]{T5x}
\Edge(T5x)(T5T4x)
\Edge(T5x)(T5T3x)
\Edge(T5x)(T5T2x)
\Edge(T5x)(T5T1x)



\Vertex[x=0, y=0-14,L=$$]{T6T1x}

\Vertex[x=2, y=2-14,L=$$]{T6T2x}
\Vertex[x=2, y=0-14,L=$$]{T6T2T1x}
\Edge(T6T2x)(T6T2T1x)

\Vertex[x=4, y=0-14,L=$$]{T6T3T1x}
\Vertex[x=6, y=2-14,L=$$]{T6T3T2x}
\Vertex[x=6, y=0-14,L=$$]{T6T3T2T1x}
\Edge(T6T3T2x)(T6T3T2T1x)
\Vertex[x=5, y=4-14,L=$$]{T6T3x}
\Edge(T6T3T1x)(T6T3x)
\Edge(T6T3T2x)(T6T3x)

\Vertex[x=8, y=0-14,L=$$]{T6T4T1x}
\Vertex[x=10, y=2-14,L=$$]{T6T4T2x}
\Vertex[x=10, y=0-14,L=$$]{T6T4T2T1x}
\Edge(T6T4T2x)(T6T4T2T1x)
\Vertex[x=12, y=0-14,L=$$]{T6T4T3T1x}
\Vertex[x=14, y=2-14,L=$$]{T6T4T3T2x}
\Vertex[x=14, y=0-14,L=$$]{T6T4T3T2T1x}
\Edge(T6T4T3T2x)(T6T4T3T2T1x)
\Vertex[x=13, y=4-14,L=$$]{T6T4T3x}
\Edge(T6T4T3T1x)(T6T4T3x)
\Edge(T6T4T3T2x)(T6T4T3x)
\Vertex[x=11,y=6-14,L=$$]{T6T4x}
\Edge(T6T4x)(T6T4T3x)
\Edge(T6T4x)(T6T4T2x)
\Edge(T6T4x)(T6T4T1x)



\Vertex[x=16, y=0-14,L=$$]{T6T5T1x}

\Vertex[x=18, y=2-14,L=$$]{T6T5T2x}
\Vertex[x=18, y=0-14,L=$$]{T6T5T2T1x}
\Edge(T6T5T2x)(T6T5T2T1x)

\Vertex[x=20, y=0-14,L=$$]{T6T5T3T1x}
\Vertex[x=22, y=2-14,L=$$]{T6T5T3T2x}
\Vertex[x=22, y=0-14,L=$$]{T6T5T3T2T1x}
\Edge(T6T5T3T2x)(T6T5T3T2T1x)
\Vertex[x=21, y=4-14,L=$$]{T6T5T3x}
\Edge(T6T5T3T1x)(T6T5T3x)
\Edge(T6T5T3T2x)(T6T5T3x)

\Vertex[x=24, y=0-14,L=$$]{T6T5T4T1x}
\Vertex[x=26, y=2-14,L=$$]{T6T5T4T2x}
\Vertex[x=26, y=0-14,L=$$]{T6T5T4T2T1x}
\Edge(T6T5T4T2x)(T6T5T4T2T1x)
\Vertex[x=28, y=0-14,L=$$]{T6T5T4T3T1x}
\Vertex[x=30, y=2-14,L=$$]{T6T5T4T3T2x}
\Vertex[x=30, y=0-14,L=$$]{T6T5T4T3T2T1x}
\Edge(T6T5T4T3T2x)(T6T5T4T3T2T1x)
\Vertex[x=29, y=4-14,L=$$]{T6T5T4T3x}
\Edge(T6T5T4T3T1x)(T6T5T4T3x)
\Edge(T6T5T4T3T2x)(T6T5T4T3x)
\Vertex[x=27,y=6-14,L=$$]{T6T5T4x}
\Edge(T6T5T4x)(T6T5T4T3x)
\Edge(T6T5T4x)(T6T5T4T2x)
\Edge(T6T5T4x)(T6T5T4T1x)

\Vertex[x=20,y=8-14,L=$$]{T6T5x}
\Edge(T6T5x)(T6T5T4x)
\Edge(T6T5x)(T6T5T3x)
\Edge(T6T5x)(T6T5T2x)
\Edge(T6T5x)(T6T5T1x)

\Vertex[x=6,y=10-14,L=$x$]{T6x}

\Edge(T6x)(T6T5x)
\Edge(T6x)(T6T4x)
\Edge(T6x)(T6T3x)
\Edge(T6x)(T6T2x)
\Edge(T6x)(T6T1x)


\AddVertexColor{blue}{T1x,T2T1x,T3T1x,T3T2T1x, T4T1x,T4T2T1x,T4T3T1x,T4T3T2T1x}
\AddVertexColor{blue}{T5T1x,T5T2T1x,T5T3T1x,T5T3T2T1x, T5T4T1x,T5T4T2T1x,T5T4T3T1x,T5T4T3T2T1x}

\AddVertexColor{blue}{T6T1x,T6T2T1x,T6T3T1x,T6T3T2T1x, T6T4T1x,T6T4T2T1x,T6T4T3T1x,T6T4T3T2T1x}
\AddVertexColor{blue}{T6T5T1x,T6T5T2T1x,T6T5T3T1x,T6T5T3T2T1x, T6T5T4T1x,T6T5T4T2T1x,T6T5T4T3T1x,T6T5T4T3T2T1x}

\AddVertexColor{red}{T2x}
\AddVertexColor{red}{T3T2x}
\AddVertexColor{red}{T4T3T2x,T4T2x}
\AddVertexColor{red}{T5T4T3T2x,T5T4T2x,T5T3T2x,T5T2x}
\AddVertexColor{red}{T6T5T4T3T2x,T6T5T4T2x,T6T5T3T2x,T6T5T2x,T6T4T3T2x,T6T4T2x,T6T3T2x,T6T2x}

\AddVertexColor{green}{T3x}
\AddVertexColor{green}{T4T3x}
\AddVertexColor{green}{T5T4T3x,T5T3x}
\AddVertexColor{green}{T6T5T4T3x,T6T5T3x,T6T4T3x,T6T3x}

\AddVertexColor{violet}{T4x}
\AddVertexColor{violet}{T5T4x}
\AddVertexColor{violet}{T6T5T4x,T6T4x}

\AddVertexColor{brown}{T5x,T6T5x}

\AddVertexColor{orange}{T6x}


\end{tikzpicture}
\end{center}
\end{figure}


\chapter{Online Coloring von bipartiten Graphen mit Advice}

Im vorhergehenden Kapitel haben wir festgestellt, dass Online Coloring auf bipartiten Graphen nicht kompetitiv ist. Wir wollen nun betrachten, wie sich der Einsatz eines Orakels im Sinne der Advice Complexity auf die Kompetivität auswirken würde -- und hoffen auf ähnlich erstaunliche Ergebnisse wie im Falle von {\sc SimpleKnapsack}.

\section{Online Coloring Algorithmus mit Advice}

\bigskip
Das Hauptproblem von Online-Färbe-Algorithmen scheint zu sein, dass es Situationen während der Präsentation der Knoten geben kann, welche zu gleichen Färbungen von Knoten auf beiden Shores führen können, wie wir durch Betrachten der Abbildungen~\ref{bipart.greedy} und \ref{bipart.greedy.besser} rekapitulieren können. Dies ist einzig der fehlenden Information über die Zukunft geschuldet. Ein allenfalls eingesetztes Orakel sollte also in genau diesem Aspekt helfen können. Die benötigte Unterstützung beschränkt sich aber auf ein schmales Band: um eine konstante Competitive Ratio $\frac k 2$ zu erreichen (sprich: $k$ Farben zuzulassen), ist einzig wichtig, die Farben $k$ und $k-1$ nicht durcheinander zu bringen \cite{bipartite}.

\bigskip
Dies führt zum Algorithmus~\ref{algo.advice}, welcher wie der First Fit-Algorithmus immer die niedrigstmögliche Farbe zuordnet. Falls aber für einen Knoten die einzigen beiden möglichen Farben $k-1$ und $k$ sind, fragt er das Orakel, wie der Knoten gefärbt werden soll. Damit wird sichergestellt, dass alle Knoten mit der Farbe $k-1$ auf der einen Seite und alle Knoten mit der Farbe $k$ auf der anderen Seite des Graphen sind.\footnote{Es mag bemerkt werden, dass die Ausgestaltung des Algorithmus trotz dessen enger Verwandtschaft zum First Fit-Algorithmus völlig anders ist. Der Grund liegt darin, dass durch die Eingabe von $k$ die Menge an möglichen Farben beschränkt ist; dadurch kann darüber iteriert werden, was die Auswahl der niedrigstmöglichen Farbe vereinfacht.}


\begin{algorithm}
\caption{Online Graph Coloring-Algorithmus mit Advice}
\label{algo.advice}
\begin{algorithmic}
\Require
	\State Der präsentierte Knoten $v$,
	\State Der bereits bekannte Graph $G' = (V', E')$,
	\State Die bereits bekannte Färbung $f : V' \rightarrow C$,
	\State Die maximale Anzahl erlaubter Farben $k$,
	\State Das Orakel $\mathcal{O} : V \rightarrow \{0,1\}$
\Ensure
	\State Die Färbung für den präsentierten Knoten $f(v) \in C$
\Statex

\State $C' \gets \{1, \dots, k\}$
\ForAll{$c \in C'$}
\ForAll{$e \in E'$}
	\State $\{w\} \gets e \cap v$
	\If{$f(w) = c$}
		\State $C' \gets C' - \{ f(w) \}$
	\EndIf
\EndFor
\EndFor

\Statex

\If{$C' \ne \{k-1,k\}$}
	\State $ f(v) \gets \min C'$
\Else
	\State $ f(v) \gets k-1+\mathcal{O}(v)$
\EndIf

\end{algorithmic}
\end{algorithm}

\section{Obere und untere Schranken für Advices}

Bezüglich den Schranken für Advices lassen sich folgende Aussagen machen:

\begin{itemize}
\item Um jeden bipartiten Graphen mit $n$ Knoten optimal färben zu können, sind höchstens $n-2$ Advices nötig. Die Begründung liegt darin, dass ein Algorithmus konstruiert werden kann, der folgendermassen funktioniert:

\begin{enumerate}
\item Der erste Knoten bekommt die Farbe $1$.
\item Bei der Präsentation des zweiten Knotens wird das Orakel gefragt, ob jedem bei der Präsentation isolierten Knoten ebenfalls die Farbe $1$ zugeordnet werden soll. Nicht-isolierte Knoten bekommen die bezüglich des Nachbarknoten entgegengesetzte Farbe. Bei einer Bejahung dieser Frage beträgt die Anzahl Advices genau $1 \le n-2$.
\item Falls das Orakel bei Schritt 2 verneint, wird es bei jedem isolierten Knoten nach der Farbe gefragt. Das Orakel würde die erste Frage aber nur verneinen, wenn es mindestens $2$ nicht isolierte Knoten gibt -- ansonsten wäre Optimalität auch noch gewährleistet, wenn die Farbe $1$ auf beiden Shores auftauchen würde. Also beträgt die Anzahl Advices höchstens $n-2$. \cite{bipartite}
\end{enumerate}

\item Um jeden bipartiten Graphen mit $n$ Knoten optimal färben zu können, sind mindestens $n-3$ Advices nötig. \cite{bipartite}

\item Um jeden bipartiten Graphen mit $n$ Knoten mit höchstens $k > 2$ Farben färben zu können, sind höchstens
$\frac{n} { \sqrt{2^{k-1}}}$
Advices nötig \cite{bipartite}. Dies ergibt sich aus der Beobachtung, dass die Befragung des Orakels, ob die Farbe $k$ oder $k-1$ zugewiesen werden soll, nur jeweils notwendig wird, wenn der aktuell präsentierte Knoten $k-2$ Kanten zu Nachbarn mit genau den Farben $\{1,\dots, k-2\}$ hat. Durch Induktion lässt sich dann zeigen, dass dies nur für jeden $ \sqrt{2^{k-1}}$ten aller $n$ Knoten der Fall ist \cite{bipartite, trotter}.


\end{itemize}


\section{Experimente}

Mit Hilfe des zu dieser Arbeit gehörenden Programms {\tt GraphBonanza} werden wir nun einige Experimente durchführen.

\subsection{Anzahl Advices für selbe Competitive Ratio wie First Fit}

In diesem ersten Experiment wollen wir untersuchen, wie viele Advice Bits durchschnittlich, minimal und maximal benötigt werden, um eine repräsentative Menge von $G(n,p)$-Graphen zu färben. Dabei wird die maximale Anzahl Farben $k$ für den Algorithmus mit Advice so gewählt, dass er jeweils dem Resultat von First Fit entspricht. Tabelle~\ref{tab.exp1p01} zeigt das Resultat für 10000 Instanzen von $G(n = 1000, p = 0.1)$. Die Daten sind über die vom First Fit-Algorithmus benötigten Anzahl Farben gruppiert (Spalte FF: \# colors) und weisen die minimale, maximale und durchschnittliche Anzahl Advices aus, welche der Algorithmus mit Advice angefragt hat. Die Tabellen~\ref{tab.exp1p05} und \ref{tab.exp1p09} zeigen die Resultate desselben Experiments für $p = 0.5$ respektive $p = 0.9$.

\begin{table}
\caption{First Fit gegen Algorithmus mit Advice für 10000 Instanzen von $G(1000, 0.1)$}
\label{tab.exp1p01}

% Table generated by Excel2LaTeX from sheet 'Sheet1'

  \centering
    \begin{tabular}{rrrrr}
    \toprule
    {\tt{FF}}: \# colors & \# samples & {\tt{AA}}: min advices & {\tt{AA}}: avg advices & {\tt{AA}}: max advices \\
    \midrule
3     & 150   & 15    & 46.5 & 174 \\
4     & 215   & 13    & 51.3 & 164 \\
5     & 210   & 9     & 50.5 & 199 \\
6     & 219   & 9     & 42.6 & 107 \\
7     & 398   & 5     & 32.5 & 127 \\
8     & 732   & 1     & 18.5& 115 \\
9     & 1087  & 1     & 15.0 & 107 \\
10    & 1499  & 1     & 12.9 & 95 \\
11    & 1701  & 1     & 11.8 & 83 \\
12    & 1639  & 1     & 10.5 & 64 \\
13    & 1141  & 1     & 9.6 & 41 \\
14    & 656   & 1     & 9.2 & 57 \\
15    & 271   & 1     & 8.0 & 33 \\
16    & 63    & 1     & 6.9 & 16 \\
17    & 11    & 1     & 6.2 & 16 \\
18    & 1     & 3     & 3.0     & 3 \\
    \bottomrule
    \end{tabular}%

\end{table}

\begin{table}
\caption{First Fit gegen Algorithmus mit Advice für 10000 Instanzen von $G(1000, 0.5)$}
\label{tab.exp1p05}
  \centering
% Table generated by Excel2LaTeX from sheet 'Sheet1'
    \begin{tabular}{rrrrr}
    \toprule
    {\tt{FF}}: \# colors & \# samples & {\tt{AA}}: min advices & {\tt{AA}}: avg advices & {\tt{AA}}: max advices \\
    \midrule
2     & 4196  & 1     & 4.0 & 34 \\
3     & 3057  & 1     & 5.5 & 25 \\
4     & 1451  & 1     & 6.0 & 28 \\
5     & 694   & 1     & 6.1 & 31 \\
6     & 340   & 1     & 6.4 & 29 \\
7     & 158   & 1     & 5.7 & 42 \\
8     & 62    & 1     & 5.7 & 20 \\
9     & 19    & 2     & 6.0     & 16 \\
10    & 11    & 2     & 6.0     & 13 \\
11    & 7     & 2     & 3.7 & 6 \\
12    & 3     & 3     & 5.0     & 8 \\
13    & 2     & 5     & 6.0     & 7 \\

    \bottomrule
    \end{tabular}%

\end{table}

\begin{table}
\caption{First Fit gegen Algorithmus mit Advice für 10000 Instanzen von $G(1000, 0.9)$}
\label{tab.exp1p09}
  \centering
% Table generated by Excel2LaTeX from sheet 'Sheet1'
\begin{tabular}{rrrrr}
\toprule
    {\tt{FF}}: \# colors & \# samples & {\tt{AA}}: min advices & {\tt{AA}}: avg advices & {\tt{AA}}: max advices \\
\midrule
2     & 9024  & 1     & 14    & 199 \\
3     & 894   & 1     & 12    & 12 \\
4     & 73    & 1     & 10    & 11 \\
5     & 9     & 1     & 4     & 4 \\
\bottomrule
\end{tabular}%


\end{table}

\begin{figure}
\caption{{\tt{FF}} gegen {\tt{AA}} für 10000 Instanzen von $G(1000, p)$, I}
\label{fig.exp1.1}
\centering

\subfloat[$p = 0.01$]

\begin{tikzpicture}
  \begin{axis}[ 
    xlabel=$k$,
    ylabel={\# advices},
legend pos=north west, xmin=1,xmax=20, height=6cm,width=14cm, axis y line=left
  ] 
    \addplot[mark=none,color=gray, stack plots=y] coordinates {
(5,73)
(6,13)
(7,1)


	};

    \addplot[mark=none,fill=gray,draw=none, stack plots=y] coordinates {
(5,53)
(6,43)
(7,12)



	} \closedcycle;

    \addplot[mark=none,color=gray] coordinates {
(5,126)
(6,56)
(7,13)



	};

\addplot[color=black] coordinates {
(5,103.3)
(6,33)
(7,3.8)


};

  \end{axis}

\begin{axis}[
height=6cm,width=14cm,
      xmin = 1, xmax = 20,
      ymin = 0, ymax = 10000,
      hide x axis,
      axis y line*=right,
      ylabel={\# samples},
      ylabel near ticks, ybar
    ]
      \addplot[blue] coordinates {
(5,646)
(6,9162)
(7,192)





	};
    \end{axis}
\end{tikzpicture}


\subfloat[$p = 0.02$]

\begin{tikzpicture}
  \begin{axis}[ 
    xlabel=$k$,
    ylabel={\# advices},
	legend pos=north west, xmin=1,xmax=20, height=6cm,width=14cm, axis y line=left
  ] 
    \addplot[mark=none,color=gray, stack plots=y] coordinates {
(6,45)
(7,6)
(8,2)
(9,1)


	};

    \addplot[mark=none,fill=gray,draw=none, stack plots=y] coordinates {
(6,34)
(7,71)
(8,38)
(9,8)



	} \closedcycle;

    \addplot[mark=none,color=gray] coordinates {
(6,79)
(7,77)
(8,40)
(9,9)



	};

\addplot[color=black] coordinates {
(6,60.4)
(7,46.9)
(8,19.3)
(9,3.6)


};

  \end{axis}

\begin{axis}[
height=6cm,width=14cm,
      xmin = 1, xmax = 20,
      ymin = 0, ymax = 10000,
      hide x axis,
      axis y line*=right,
      ylabel={\# samples},
      ylabel near ticks, ybar
    ]
      \addplot[blue] coordinates {
(6,15)
(7,2501)
(8,7302)
(9,182)




	};
    \end{axis}
\end{tikzpicture}


\subfloat[$p = 0.05$]

\begin{tikzpicture}
  \begin{axis}[ 
    xlabel=$k$,
    ylabel={\# advices},
	legend pos=north west, xmin=1,xmax=20, height=6cm,width=14cm, axis y line=left
  ] 
    \addplot[mark=none,color=gray, stack plots=y] coordinates {
(3,69)
(4,42)
(5,29)
(6,8)
(7,5)
(8,2)
(9,1)
(10,1)
(11,1)
(12,1)
(13,1)



	};

    \addplot[mark=none,fill=gray,draw=none, stack plots=y] coordinates {
(3,0)
(4,128)
(5,101)
(6,107)
(7,61)
(8,83)
(9,64)
(10,48)
(11,46)
(12,29)
(13,16)




	} \closedcycle;

    \addplot[mark=none,color=gray] coordinates {
(3,69)
(4,170)
(5,130)
(6,115)
(7,66)
(8,85)
(9,65)
(10,49)
(11,47)
(12,30)
(13,17)




	};

\addplot[color=black] coordinates {
(3,69)
(4,117.3)
(5,72.6)
(6,29.9)
(7,21.4)
(8,20.1)
(9,18.5)
(10,16.8)
(11,14.6)
(12,10.6)
(13,5.7)



};

  \end{axis}

\begin{axis}[
height=6cm,width=14cm,
      xmin = 1, xmax = 20,
      ymin = 0, ymax = 10000,
      hide x axis,
      axis y line*=right,
      ylabel={\# samples},
      ylabel near ticks, ybar 
    ]
      \addplot[blue] coordinates {
(3,1)
(4,4)
(5,5)
(6,25)
(7,132)
(8,496)
(9,1436)
(10,2931)
(11,3345)
(12,1503)
(13,122)





	};
    \end{axis}
\end{tikzpicture}


\end{figure}

\begin{figure}
\caption{{\tt{FF}} gegen {\tt{AA}} für 10000 Instanzen von $G(1000, p)$, II}
\label{fig.exp1.2}
\centering

\subfloat[$p = 0.1$]

\begin{tikzpicture}
  \begin{axis}[ 
    xlabel=$k$,
    ylabel={\# advices},
	legend pos=north west, xmin=1,xmax=20, height=6cm,width=14cm, axis y line=left
  ] 
    \addplot[mark=none,color=gray, stack plots=y] coordinates {
(2,17)
(3,15)
(4,13)
(5,9)
(6,9)
(7,5)
(8,1)
(9,1)
(10,1)
(11,1)
(12,1)
(13,1)
(14,1)
(15,1)
(16,1)
(17,1)
(18,3)

	};

    \addplot[mark=none,fill=gray,draw=none, stack plots=y] coordinates {
(2,10)
(3,159)
(4,151)
(5,190)
(6,98)
(7,122)
(8,114)
(9,106)
(10,94)
(11,82)
(12,63)
(13,40)
(14,56)
(15,32)
(16,15)
(17,15)
(18,0)


	} \closedcycle;

    \addplot[mark=none,color=gray] coordinates {
(2,27)
(3,174)
(4,164)
(5,199)
(6,107)
(7,127)
(8,115)
(9,107)
(10,95)
(11,83)
(12,64)
(13,41)
(14,57)
(15,33)
(16,16)
(17,16)
(18,3)


	};

\addplot[color=black] coordinates {
(2,20.9)
(3,46.5)
(4,51.3)
(5,50.5)
(6,42.6)
(7,32.5)
(8,18.5)
(9,15)
(10,12.9)
(11,11.8)
(12,10.5)
(13,9.6)
(14,9.2)
(15,8)
(16,6.6)
(17,6.2)
(18,3)

};

  \end{axis}
\begin{axis}[
height=6cm,width=14cm,
      xmin = 1, xmax = 20,
      ymin = 0, ymax = 10000,
      hide x axis,
      axis y line*=right,
      ylabel={\# samples},
      ylabel near ticks, ybar
    ]
      \addplot[blue] coordinates {
(2,7)
(3,150)
(4,215)
(5,210)
(6,219)
(7,398)
(8,732)
(9,1087)
(10,1499)
(11,1701)
(12,1639)
(13,1141)
(14,656)
(15,271)
(16,63)
(17,11)
(18,1)



	};
    \end{axis}
\end{tikzpicture}

\subfloat[$p = 0.2$]

\begin{tikzpicture}
  \begin{axis}[ 
    xlabel=$k$,
    ylabel={\# advices},
	legend pos=north west, xmin=1,xmax=20, height=6cm,width=14cm, axis y line=left
  ] 
    \addplot[mark=none,color=gray, stack plots=y] coordinates {
(2,3)
(3,3)
(4,3)
(5,3)
(6,3)
(7,4)
(8,2)
(9,1)
(10,1)
(11,1)
(12,1)
(13,1)
(14,1)
(15,1)
(16,1)
(17,1)
(18,4)
(19,4)

	};

    \addplot[mark=none,fill=gray,draw=none, stack plots=y] coordinates {
(2,16)
(3,65)
(4,79)
(5,82)
(6,72)
(7,87)
(8,75)
(9,56)
(10,65)
(11,52)
(12,50)
(13,39)
(14,38)
(15,32)
(16,23)
(17,15)
(18,3)
(19,2)



	} \closedcycle;

    \addplot[mark=none,color=gray] coordinates {
(2,19)
(3,68)
(4,82)
(5,85)
(6,75)
(7,91)
(8,77)
(9,57)
(10,66)
(11,53)
(12,51)
(13,40)
(14,39)
(15,33)
(16,24)
(17,16)
(18,7)
(19,6)



	};

\addplot[color=black] coordinates {
(2,9.7)
(3,20.3)
(4,20.1)
(5,19.9)
(6,19.9)
(7,19.1)
(8,18.1)
(9,16.1)
(10,12.6)
(11,10.7)
(12,8.5)
(13,7.7)
(14,7.5)
(15,6.5)
(16,6)
(17,6.8)
(18,5)
(19,4.5)


};


  \end{axis}

\begin{axis}[
height=6cm,width=14cm,
      xmin = 1, xmax = 20,
      ymin = 0, ymax = 10000,
      hide x axis,
      axis y line*=right,
      ylabel={\# samples},
      ylabel near ticks, ybar
    ]
      \addplot[blue] coordinates {
(2,369)
(3,1405)
(4,1199)
(5,1064)
(6,905)
(7,764)
(8,668)
(9,689)
(10,757)
(11,696)
(12,593)
(13,412)
(14,262)
(15,143)
(16,49)
(17,15)
(18,6)
(19,4)




	};
    \end{axis}

\end{tikzpicture}

\subfloat[$p = 0.3$]

\begin{tikzpicture}
  \begin{axis}[ 
    xlabel=$k$,
    ylabel={\# advices},
	legend pos=north west, xmin=1,xmax=20, height=6cm,width=14cm, axis y line=left
  ] 
    \addplot[mark=none,color=gray, stack plots=y] coordinates {
(2,1)
(3,1)
(4,2)
(5,2)
(6,2)
(7,2)
(8,2)
(9,2)
(10,2)
(11,2)
(12,1)
(13,2)
(14,1)
(15,2)
(16,2)
(17,2)



	};

    \addplot[mark=none,fill=gray,draw=none, stack plots=y] coordinates {
(2,16)
(3,42)
(4,82)
(5,72)
(6,64)
(7,69)
(8,47)
(9,56)
(10,28)
(11,32)
(12,36)
(13,29)
(14,16)
(15,15)
(16,16)
(17,8)




	} \closedcycle;

    \addplot[mark=none,color=gray] coordinates {
(2,17)
(3,43)
(4,84)
(5,74)
(6,66)
(7,71)
(8,49)
(9,58)
(10,30)
(11,34)
(12,37)
(13,31)
(14,17)
(15,17)
(16,18)
(17,10)




	};

\addplot[color=black] coordinates {
(2,6.7)
(3,11.5)
(4,11.6)
(5,11.9)
(6,12.1)
(7,12.2)
(8,12.5)
(9,12)
(10,10.4)
(11,9.3)
(12,8.7)
(13,8.5)
(14,6.2)
(15,6.5)
(16,7.6)
(17,5.5)



};


  \end{axis}

\begin{axis}[
height=6cm,width=14cm,
      xmin = 1, xmax = 20,
      ymin = 0, ymax = 10000,
      hide x axis,
      axis y line*=right,
      ylabel={\# samples},
      ylabel near ticks, ybar
    ]
      \addplot[blue] coordinates {
(2,1366)
(3,2509)
(4,1762)
(5,1274)
(6,883)
(7,647)
(8,455)
(9,336)
(10,250)
(11,166)
(12,141)
(13,86)
(14,70)
(15,34)
(16,10)
(17,11)




	};
    \end{axis}


\end{tikzpicture}


\end{figure}



\begin{figure}
\caption{{\tt{FF}} gegen {\tt{AA}} für 10000 Instanzen von $G(1000, p)$, III}
\label{fig.exp1.3}
\centering

\subfloat[$p = 0.4$]

\begin{tikzpicture}
  \begin{axis}[ 
    xlabel=$k$,
    ylabel={\# advices},
	legend pos=north west, xmin=1,xmax=20, height=6cm,width=14cm, axis y line=left
  ] 
    \addplot[mark=none,color=gray, stack plots=y] coordinates {
(2,1)
(3,1)
(4,1)
(5,1)
(6,1)
(7,1)
(8,1)
(9,1)
(10,2)
(11,1)
(12,2)
(13,3)
(14,1)
(15,2)
(16,2)
(19,2)


	};

    \addplot[mark=none,fill=gray,draw=none, stack plots=y] coordinates {
(2,17)
(3,31)
(4,45)
(5,50)
(6,35)
(7,27)
(8,37)
(9,19)
(10,22)
(11,27)
(12,29)
(13,11)
(14,17)
(15,3)
(16,1)
(19,0)



	} \closedcycle;

    \addplot[mark=none,color=gray] coordinates {
(2,18)
(3,32)
(4,46)
(5,51)
(6,36)
(7,28)
(8,38)
(9,20)
(10,24)
(11,28)
(12,31)
(13,14)
(14,18)
(15,5)
(16,3)
(19,2)



	};

\addplot[color=black] coordinates {
(2,5)
(3,7.5)
(4,8.2)
(5,8.1)
(6,8.4)
(7,8.2)
(8,8.3)
(9,7.8)
(10,7.9)
(11,9.7)
(12,8.9)
(13,6.8)
(14,8.8)
(15,3.5)
(16,2.5)
(19,2)


};

  \end{axis}
\begin{axis}[
height=6cm,width=14cm,
      xmin = 1, xmax = 20,
      ymin = 0, ymax = 10000,
      hide x axis,
      axis y line*=right,
      ylabel={\# samples},
      ylabel near ticks, ybar
    ]
      \addplot[blue] coordinates {
(2,2719)
(3,2934)
(4,1859)
(5,1032)
(6,662)
(7,346)
(8,195)
(9,104)
(10,66)
(11,42)
(12,19)
(13,12)
(14,5)
(15,2)
(16,2)
(19,1)




	};
    \end{axis}
\end{tikzpicture}

\subfloat[$p = 0.5$]

\begin{tikzpicture}
  \begin{axis}[ 
    xlabel=$k$,
    ylabel={\# advices},
	legend pos=north west, xmin=1,xmax=20, height=6cm,width=14cm, axis y line=left
  ] 
    \addplot[mark=none,color=gray, stack plots=y] coordinates {
(2,1)
(3,1)
(4,1)
(5,1)
(6,1)
(7,1)
(8,1)
(9,2)
(10,2)
(11,2)
(12,3)
(13,5)



	};

    \addplot[mark=none,fill=gray,draw=none, stack plots=y] coordinates {
(2,33)
(3,24)
(4,27)
(5,30)
(6,28)
(7,41)
(8,19)
(9,14)
(10,11)
(11,4)
(12,5)
(13,2)




	} \closedcycle;

    \addplot[mark=none,color=gray] coordinates {
(2,34)
(3,25)
(4,28)
(5,31)
(6,29)
(7,42)
(8,20)
(9,16)
(10,13)
(11,6)
(12,8)
(13,7)




	};

\addplot[color=black] coordinates {
(2,4)
(3,5.5)
(4,6)
(5,6.1)
(6,6.4)
(7,5.7)
(8,5.7)
(9,6)
(10,6)
(11,3.7)
(12,5)
(13,6)



};


  \end{axis}

\begin{axis}[
height=6cm,width=14cm,
      xmin = 1, xmax = 20,
      ymin = 0, ymax = 10000,
      hide x axis,
      axis y line*=right,
      ylabel={\# samples},
      ylabel near ticks, ybar
    ]
      \addplot[blue] coordinates {
(2,4196)
(3,3057)
(4,1451)
(5,694)
(6,340)
(7,158)
(8,62)
(9,19)
(10,11)
(11,7)
(12,3)
(13,2)





	};
    \end{axis}

\end{tikzpicture}

\subfloat[$p = 0.6$]

\begin{tikzpicture}
  \begin{axis}[ 
    xlabel=$k$,
    ylabel={\# advices},
	legend pos=north west, xmin=1,xmax=20, height=6cm,width=14cm, axis y line=left
  ] 
    \addplot[mark=none,color=gray, stack plots=y] coordinates {
(2,1)
(3,1)
(4,1)
(5,1)
(6,1)
(7,1)
(8,2)
(9,2)
(10,5)




	};

    \addplot[mark=none,fill=gray,draw=none, stack plots=y] coordinates {
(2,17)
(3,19)
(4,21)
(5,19)
(6,17)
(7,15)
(8,13)
(9,3)
(10,4)





	} \closedcycle;

    \addplot[mark=none,color=gray] coordinates {
(2,18)
(3,20)
(4,22)
(5,20)
(6,18)
(7,16)
(8,15)
(9,5)
(10,9)





	};

\addplot[color=black] coordinates {
(2,3.3)
(3,4.3)
(4,4.5)
(5,5)
(6,4.5)
(7,5.6)
(8,5.2)
(9,4)
(10,7)




};


  \end{axis}

\begin{axis}[
height=6cm,width=14cm,
      xmin = 1, xmax = 20,
      ymin = 0, ymax = 10000,
      hide x axis,
      axis y line*=right,
      ylabel={\# samples},
      ylabel near ticks, ybar
    ]
      \addplot[blue] coordinates {
(2,5584)
(3,2825)
(4,1048)
(5,361)
(6,117)
(7,49)
(8,10)
(9,4)
(10,2)






	};
    \end{axis}


\end{tikzpicture}


\end{figure}








\chapter{Kommentierung der Implementation des Programms {\tt GraphBonanza}}

In den nachfolgenden Abschnitten sollen ein Überblick über die Anforderungen an das Programm sowie deren technische Umsetzung gegeben werden. Wo notwendig, sinnvoll und/oder interessant, werden auch einzelne Code-Abschnitte wiedergegeben und kommentiert.

\section{Anforderungen}

Pi pa po

\section{Umfeld, Architektur und verwendete Bibliotheken}

Das Programm wurde als reine Browser-Lösung unter Verwendung von {\tt HTML} und {\tt JavaScript} umgesetzt. Dadurch ist es theoretisch auf sämtlichen gängigen Plattformen lauffähig und hat keine Abhängigkeiten zu anderen Komponenten und Diensten wie Laufzeitumgebungen, Webservern, Datenbanken oder ähnlichem. Der Nachvollziehbarkeit und der Verwendung durch Dritte ist ebenfalls förderlich, dass kein Compiler vonnöten ist.

In der Praxis wird die Portabilität natürlich eingeschränkt durch die teilweise unvollständige und fehlerhafte Implementierung von {\tt JavaScript}, {\tt HTML} und {\tt CSS} durch veraltete Browser wie zum Beispiel Internet Explorer. Es zeigt sich aber, das das Programm in aktuellen Versionen von {\tt Firefox} und {\tt Chrome} wie erwartet funktioniert.

\bigskip
Das UML-Diagramm in Abbildung~\ref{fig.arch} zeigt einen Überblick über die implementierten Klassen.

\section{Die {\tt GraphBuilder}-Klasse}

\section{Die {\tt FirstFitAlgo}-Klasse}

\section{Die {\tt AlgoWithAdvice}-Klasse}

\section{Die {\tt Looper}-Klasse}

\section{User Interface}

\section{Caveats}

\bibliography{biblio}
\bibliographystyle{plain}

\listoffigures
\listofalgorithms


\end{document}
